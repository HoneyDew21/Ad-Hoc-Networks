# -*- coding: utf-8 -*-
"""Dynamic Path Establishment in Ad Hoc Networks with RREQ and RREP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sknDKbjpX4J9IHiu9Jk25be04sIpmEfj
"""

import random
import time
import threading
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.patches import FancyArrowPatch

class Node:
    def __init__(self, id, x, y):
        self.id = id
        self.x = x
        self.y = y
        self.routing_table = {}
        self.neighbors = []

    def move(self, area_size):
        """ Move node randomly """
        self.x = (self.x + random.randint(-1, 1)) % area_size
        self.y = (self.y + random.randint(-1, 1)) % area_size

    def send_rreq(self, target_node, thread_id, color):
        """ Send Route Request (RREQ) with thread ID and color for arrow """
        print(f"[Thread-{thread_id}] Node {self.id} sends RREQ to Node {target_node.id}")
        target_node.receive_rreq(self, thread_id, color)

    def receive_rreq(self, sender_node, thread_id, color):
        """ Receive RREQ and send RREP with thread ID and color for arrow """
        if self.id != sender_node.id:
            print(f"[Thread-{thread_id}] Node {self.id} receives RREQ from Node {sender_node.id}")
            self.send_rrep(sender_node, thread_id, color)

    def send_rrep(self, sender_node, thread_id, color):
        """ Send Route Reply (RREP) with thread ID and color for arrow """
        print(f"[Thread-{thread_id}] Node {self.id} sends RREP to Node {sender_node.id}")
        sender_node.update_routing_table(self, thread_id)

    def update_routing_table(self, neighbor_node, thread_id):
        """ Update the routing table with the neighbor's route """
        self.routing_table[neighbor_node.id] = (neighbor_node.x, neighbor_node.y)
        print(f"[Thread-{thread_id}] Node {self.id} updates routing table: {self.routing_table}")

class AdHocNetwork:
    def __init__(self, num_nodes, area_size):
        self.nodes = [Node(i, random.randint(0, area_size), random.randint(0, area_size)) for i in range(num_nodes)]
        self.area_size = area_size

    def update_network(self):
        """ Simulate node movement and network behavior """
        for node in self.nodes:
            node.move(self.area_size)
        self.simulate_routing()

    def simulate_routing(self):
        """ Simulate multiple route discoveries in parallel between nodes """
        threads = []
        for _ in range(5):  # Simulate 5 random route discoveries
            source_node = random.choice(self.nodes)
            target_node = random.choice(self.nodes)
            color = random.choice(['red', 'green', 'yellow', 'purple', 'orange'])  # Different arrow colors
            thread_id = threading.get_ident()  # Get the thread ID for identification
            thread = threading.Thread(target=self.simulate_single_routing, args=(source_node, target_node, thread_id, color))
            threads.append(thread)
            thread.start()

        # Wait for all threads to finish
        for thread in threads:
            thread.join()

    def simulate_single_routing(self, source_node, target_node, thread_id, color):
        """ Simulate a single RREQ/RREP exchange between two nodes with thread ID and color """
        print(f"\n[Thread-{thread_id}] Simulating route discovery between Node {source_node.id} and Node {target_node.id}...")
        source_node.send_rreq(target_node, thread_id, color)

    def visualize_network(self):
        """ Visualize the network with node positions and routing paths """
        G = nx.DiGraph()  # Directed graph for showing direction of routes
        node_colors = []
        edge_colors = []
        edge_labels = {}

        for node in self.nodes:
            G.add_node(node.id, pos=(node.x, node.y))
            node_colors.append('lightblue')  # Lighter color for nodes
            for neighbor_id in node.routing_table:
                G.add_edge(node.id, neighbor_id)
                edge_colors.append('darkgray')  # Subtle color for edges

        # Get positions and create the plot
        pos = nx.get_node_attributes(G, 'pos')
        plt.figure(figsize=(8, 8))
        nx.draw_networkx_nodes(G, pos, node_size=600, node_color=node_colors, alpha=0.7)
        nx.draw_networkx_labels(G, pos, font_size=12, font_weight='bold')

        # Draw edges with arrows
        nx.draw_networkx_edges(G, pos, edgelist=G.edges(), width=2, edge_color=edge_colors, alpha=0.5, arrows=True)

        # Add arrows with different colors to indicate direction of RREQ and RREP
        for source in self.nodes:
            for target_id in source.routing_table:
                target = next(node for node in self.nodes if node.id == target_id)
                arrow = FancyArrowPatch(pos[source.id], pos[target.id], mutation_scale=12, color=random.choice(['red', 'green', 'yellow', 'purple', 'orange']), alpha=0.6)
                plt.gca().add_patch(arrow)

        # Title and plot adjustments
        plt.title("Ad Hoc Network Routing (RREQ/RREP)", fontsize=14)
        plt.axis("off")  # Hide axes for better clarity
        plt.show()

# Initialize the Ad Hoc Network
network = AdHocNetwork(num_nodes=10, area_size=20)

# Update and visualize the network for 10 iterations with parallelism
for _ in range(10):
    network.update_network()
    network.visualize_network()
    time.sleep(1)  # Pause for visualization update

